{"componentChunkName":"component---src-templates-blog-post-js","path":"/WEB/rest-api/","result":{"data":{"site":{"siteMetadata":{"title":"Juwon's blog","author":"Juwon Lee","siteUrl":"https://gatsby-starter-bee.netlify.com","comment":{"disqusShortName":"","utterances":"JaeYeopHan/gatsby-starter-bee"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"cb6e553e-9410-54e2-b8e9-7add8ff10d60","excerpt":"REST 는 Representational State Transfer 의 약자로 아키텍처 스타일이다. 아키텍처 스타일은 아키텍처 패턴과는 조금 다른데 아키텍처 패턴은 어떤 반복되는 문제 상황을 해결하는 도구 이고, 아키텍처 스타일은 반복되는 아키텍처 디자인을 의미한다. REST 아키텍처 스타일은 6가지 제약조건으로 구성된다. 이 가이드라인을 따르는 API 를 RESTful API 라고 한다. REST 제약조건 클라이언트-서버 Client-Server 상태가 없다 Stateless…","html":"<p>REST 는 Representational State Transfer 의 약자로 아키텍처 스타일이다.</p>\n<p>아키텍처 스타일은 아키텍처 패턴과는 조금 다른데</p>\n<p>아키텍처 패턴은 어떤 반복되는 문제 상황을 해결하는 도구 이고,</p>\n<p>아키텍처 스타일은 반복되는 아키텍처 디자인을 의미한다.</p>\n<p>REST 아키텍처 스타일은 6가지 제약조건으로 구성된다.</p>\n<p>이 가이드라인을 따르는 API 를 RESTful API 라고 한다.</p>\n<p><strong>REST 제약조건</strong></p>\n<ul>\n<li>클라이언트-서버 <em>Client-Server</em></li>\n<li>상태가 없다 <em>Stateless</em></li>\n<li>캐시되는 데이터 <em>Cacheable</em></li>\n<li>일관적인 인터페이스 <em>Uniform Interface</em></li>\n<li>레이어 시스템 <em>Layered System</em></li>\n<li>코드-온-디맨드 <em>Code-On-Demand</em> (선택사항)</li>\n</ul>\n<h3 id=\"client-server\" style=\"position:relative;\"><a href=\"#client-server\" aria-label=\"client server permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Client-Server</h3>\n<p><strong><em>리소스를 관리하는 서버가 존재하고 다수의 클라이언트가 리소스를 소비하기 위해</em></strong></p>\n<p><strong><em>네트워크를 통해 서버에 접근하는 구조</em></strong> 를 의미한다.</p>\n<p>이런 구조 중 가장 친숙한 것이 바로 웹 어플리케이션.</p>\n<h3 id=\"stateless\" style=\"position:relative;\"><a href=\"#stateless\" aria-label=\"stateless permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stateless</h3>\n<p><strong><em>클라이언트가 서버에 요청을 보낼 때 이전 요청의 영향을 받지 않음</em></strong> 을 의미한다.</p>\n<p>예를 들어 /login 으로 로그인 요청을 보내고 로그인이 되어</p>\n<p>다음 페이지인 /page 로 넘어갔다고 가정하자.</p>\n<p>/page 로 리소스를 불러올 때 이전 요청에서 login 한 사실을 서버가 알고 있어야 한다면</p>\n<p>그것은 상태가 있는 <strong>Stateful</strong> 아키텍처다.</p>\n<p>서버가 그 사실을 알지 못한다면 상태가 없는 것이다.</p>\n<blockquote>\n<p>그럼 로그인을 어떻게 하고, 부득이한 경우 상태를 어떻게 유지할까?</p>\n</blockquote>\n<p>클라이언트는 서버에 요청을 할 때마다 요청에 리소스를 받기 위한 모든 정보를 포함해야 한다.</p>\n<p>예를 들어 로그인의 경우 서버는 로그인 상태를 유지하지 못하므로 요청을 보낼 때마다</p>\n<p>로그인 정보를 항상 함께 보내야 한다.</p>\n<p>리소스를 수정한 후 수정한 상태를 유지해야 하는 경우에는</p>\n<p>서버가 아닌 DB 같은 퍼시스턴스에 상태를 저장해야 한다.</p>\n<p>HTTP 는 기본적으로 상태가 없는 프로토콜이다.</p>\n<p>따라서 HTTP 를 사용하는 웹 어플리케이션은 기본적으로 상태가 없는 구조를 따른다.</p>\n<h3 id=\"cacheable\" style=\"position:relative;\"><a href=\"#cacheable\" aria-label=\"cacheable permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Cacheable</h3>\n<p>서버에서 리소스를 리턴할 때 <strong><em>캐시가 가능한지 아닌지 명시</em></strong> 할 수 있어야 한다.</p>\n<p>HTTP 에서는 cache-control 이라는 헤더에 리소스 캐시 여부를 명시할 수 있다.</p>\n<h3 id=\"uniform-interface\" style=\"position:relative;\"><a href=\"#uniform-interface\" aria-label=\"uniform interface permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Uniform Interface</h3>\n<p>시스템 또는 어플리케이션의 리소스에 접근할 때 인터페이스가 일관적이어야 한다.</p>\n<p>예를들어 Todo 아이템을 가져오려고 <a href=\"http://jujuwon.github.io/todo\">http://jujuwon.github.io/todo</a> 를 사용했다고 가정하자.</p>\n<p>이 때 Todo 아이템을 업데이트하는 데 <a href=\"http://jujuwon2.github.io/todo\">http://jujuwon2.github.io/todo</a> 를 사용해야 한다면</p>\n<p>이는 일관적인 인터페이스가 아니다.</p>\n<p>URI 의 일관성 외에도 다른 예를 생각해보자.</p>\n<p>예를 들어 <a href=\"http://jujuwon.github.io/todo\">http://jujuwon.github.io/todo</a> 는 JSON 형식의 리소스를 리턴했다.</p>\n<p>그런데 <a href=\"http://jujuwon.github.io/todo\">http://jujuwon2.github.io/todo</a> 는 HTML 을 리턴했다.</p>\n<p>이런 인터페이스는 리턴 타입에 일관성이 있다고 할 수 없다.</p>\n<p>이렇게 리소스에 접근하는 방식, 요청 형식, 그리고 응답 형식,</p>\n<p>즉 <strong><em>URL 요청의 형태와 응답의 형태가 어플리케이션 전반에 걸쳐 일관적</em></strong> 인 것이</p>\n<p>일관적인 인터페이스이다.</p>\n<p>또한 서버가 리턴하는 응답에는 해당 리소스를 수정할 수 있는 충분한 정보가 있어야 한다.</p>\n<p>예를 들어 Todo 아이템을 받아왔는데 ID 가 없다면</p>\n<p>이후 클라이언트는 Todo 아이템을 업데이트하거나 삭제하지 못한다.</p>\n<p>리소스를 수정하는 데 충분한 정보가 부족한 것이다.</p>\n<h3 id=\"layered-system\" style=\"position:relative;\"><a href=\"#layered-system\" aria-label=\"layered system permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Layered System</h3>\n<p>클라이언트가 서버에 요청을 할 때 여러 개의 레이어로 된 서버를 거칠 수 있다.</p>\n<p>예를 들어 서버가 인증 서버, 캐싱 서버, 로드 밸런서를 거쳐서</p>\n<p>최종적으로 어플리케이션에 도착한다고 가정하자.</p>\n<p>이 사이의 레이어들은 요청과 응답에 어떤 영향을 미치지 않으며</p>\n<p>클라이언트는 서버의 레이어 존재 유무를 알지 못한다.</p>\n<h3 id=\"code-on-demand\" style=\"position:relative;\"><a href=\"#code-on-demand\" aria-label=\"code on demand permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code-On-Demand</h3>\n<p>이 제약조건은 선택사항이다.</p>\n<p>클라이언트는 서버에 코드를 요청할 수 있고 서버가 리턴한 코드를 실행할 수 있다.</p>\n<p>REST 는 HTTP 와 다르다.</p>\n<p>REST 는 HTTP 를 이용해 구현하기 쉽고 대부분 그렇게 구현하지만</p>\n<p>엄밀히 말하면 REST 는 아키텍처이고,</p>\n<p>HTTP 는 REST 아키텍처를 구현할 때 사용하면 쉬운 프로토콜이다.</p>","frontmatter":{"title":"REST API 란","date":"January 14, 2022"}}},"pageContext":{"slug":"/WEB/rest-api/","previous":{"fields":{"slug":"/Container/lxc/"},"frontmatter":{"title":"LXC - Linux Container"}},"next":{"fields":{"slug":"/WEB/fetch-api/"},"frontmatter":{"title":"Fetch API"}}}},"staticQueryHashes":["2486386679","3128451518"]}