---
title: 'REST API 란'
date: 2022-01-14 15:55:13
category: 'WEB'
draft: false
---

REST 는 Representational State Transfer 의 약자로 아키텍처 스타일이다.

아키텍처 스타일은 아키텍처 패턴과는 조금 다른데

아키텍처 패턴은 어떤 반복되는 문제 상황을 해결하는 도구 이고,

아키텍처 스타일은 반복되는 아키텍처 디자인을 의미한다.

REST 아키텍처 스타일은 6가지 제약조건으로 구성된다.

이 가이드라인을 따르는 API 를 RESTful API 라고 한다.

**REST 제약조건**

- 클라이언트-서버 *Client-Server*
- 상태가 없다 *Stateless*
- 캐시되는 데이터 *Cacheable*
- 일관적인 인터페이스 *Uniform Interface*
- 레이어 시스템 *Layered System*
- 코드-온-디맨드 *Code-On-Demand* (선택사항)

### Client-Server

***리소스를 관리하는 서버가 존재하고 다수의 클라이언트가 리소스를 소비하기 위해***

***네트워크를 통해 서버에 접근하는 구조*** 를 의미한다.

이런 구조 중 가장 친숙한 것이 바로 웹 어플리케이션.

### Stateless

***클라이언트가 서버에 요청을 보낼 때 이전 요청의 영향을 받지 않음*** 을 의미한다.

예를 들어 /login 으로 로그인 요청을 보내고 로그인이 되어

다음 페이지인 /page 로 넘어갔다고 가정하자.

/page 로 리소스를 불러올 때 이전 요청에서 login 한 사실을 서버가 알고 있어야 한다면

그것은 상태가 있는 **Stateful** 아키텍처다.

서버가 그 사실을 알지 못한다면 상태가 없는 것이다.

> 그럼 로그인을 어떻게 하고, 부득이한 경우 상태를 어떻게 유지할까?
> 

클라이언트는 서버에 요청을 할 때마다 요청에 리소스를 받기 위한 모든 정보를 포함해야 한다.

예를 들어 로그인의 경우 서버는 로그인 상태를 유지하지 못하므로 요청을 보낼 때마다

로그인 정보를 항상 함께 보내야 한다.

리소스를 수정한 후 수정한 상태를 유지해야 하는 경우에는

서버가 아닌 DB 같은 퍼시스턴스에 상태를 저장해야 한다.

HTTP 는 기본적으로 상태가 없는 프로토콜이다.

따라서 HTTP 를 사용하는 웹 어플리케이션은 기본적으로 상태가 없는 구조를 따른다.

### Cacheable

서버에서 리소스를 리턴할 때 ***캐시가 가능한지 아닌지 명시*** 할 수 있어야 한다.

HTTP 에서는 cache-control 이라는 헤더에 리소스 캐시 여부를 명시할 수 있다.

### Uniform Interface

시스템 또는 어플리케이션의 리소스에 접근할 때 인터페이스가 일관적이어야 한다.

예를들어 Todo 아이템을 가져오려고 [http://jujuwon.github.io/todo](http://jujuwon.github.io/todo) 를 사용했다고 가정하자.

이 때 Todo 아이템을 업데이트하는 데 [http://jujuwon2.github.io/todo](http://jujuwon2.github.io/todo) 를 사용해야 한다면

이는 일관적인 인터페이스가 아니다.

URI 의 일관성 외에도 다른 예를 생각해보자.

예를 들어 [http://jujuwon.github.io/todo](http://jujuwon.github.io/todo) 는 JSON 형식의 리소스를 리턴했다.

그런데 [http://jujuwon2.github.io/todo](http://jujuwon.github.io/todo) 는 HTML 을 리턴했다.

이런 인터페이스는 리턴 타입에 일관성이 있다고 할 수 없다.

이렇게 리소스에 접근하는 방식, 요청 형식, 그리고 응답 형식,

즉 ***URL 요청의 형태와 응답의 형태가 어플리케이션 전반에 걸쳐 일관적*** 인 것이

일관적인 인터페이스이다.

또한 서버가 리턴하는 응답에는 해당 리소스를 수정할 수 있는 충분한 정보가 있어야 한다.

예를 들어 Todo 아이템을 받아왔는데 ID 가 없다면

이후 클라이언트는 Todo 아이템을 업데이트하거나 삭제하지 못한다.

리소스를 수정하는 데 충분한 정보가 부족한 것이다.

### Layered System

클라이언트가 서버에 요청을 할 때 여러 개의 레이어로 된 서버를 거칠 수 있다.

예를 들어 서버가 인증 서버, 캐싱 서버, 로드 밸런서를 거쳐서

최종적으로 어플리케이션에 도착한다고 가정하자.

이 사이의 레이어들은 요청과 응답에 어떤 영향을 미치지 않으며

클라이언트는 서버의 레이어 존재 유무를 알지 못한다.

### Code-On-Demand

이 제약조건은 선택사항이다.

클라이언트는 서버에 코드를 요청할 수 있고 서버가 리턴한 코드를 실행할 수 있다.

REST 는 HTTP 와 다르다.

REST 는 HTTP 를 이용해 구현하기 쉽고 대부분 그렇게 구현하지만

엄밀히 말하면 REST 는 아키텍처이고,

HTTP 는 REST 아키텍처를 구현할 때 사용하면 쉬운 프로토콜이다.